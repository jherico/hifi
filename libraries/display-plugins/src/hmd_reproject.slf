//
//  Created by Bradley Austin Davis on 2016/07/11
//  Copyright 2013-2016 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//

struct ReprojectionData {
    mat4 projections[2];
    mat4 inverseProjections[2];
    mat4 rotation;
};

layout(std140) uniform reprojectionBuffer {
    ReprojectionData reprojection;
};

in vec2 varTexCoord0;

out vec4 outFragColor;

uniform sampler2D sampler;

vec4 toNdcSpaceFromUv(vec2 uv) {
    vec4 result = vec4(uv, 0.0, 1.0);
    result.xy *= 2.0;
    result.xy -= 1.0;
    return result;
}

vec4 toNdcSpaceFromStereoUv(vec2 uv) {
    if (uv.x >= 0.5) {
        uv.x -= 0.5;
    }
    uv.x *= 2.0;
    return toNdcSpaceFromUv(uv); 
}

vec2 toUvFromNdcSpace(vec4 ndc) {
    ndc /= ndc.w;
    vec2 result = ndc.xy;
    result += 1.0;
    result /= 2.0;
    return result;
}

void main() {
    vec2 uv = varTexCoord0;
    
    mat4 eyeInverseProjection;
    mat4 eyeProjection;
    
    vec2 uvmin = vec2(0.0);
    vec2 uvmax = vec2(1.0);
    
    // determine the correct projection and inverse projection to use.
    if (uv.x < 0.5) {
        uvmax.x = 0.5;
        eyeInverseProjection = reprojection.inverseProjections[0];
        eyeProjection = reprojection.projections[0];
    } else {
        uvmin.x = 0.5;
        uvmax.x = 1.0;
        eyeInverseProjection = reprojection.inverseProjections[1];
        eyeProjection = reprojection.projections[1];
    }
    
    // Account for stereo in calculating the per-eye NDC coordinates
    vec4 ndcSpace = toNdcSpaceFromStereoUv(varTexCoord0);
    
    // Convert from NDC to eyespace
    vec4 eyeSpace = eyeInverseProjection * ndcSpace;
    eyeSpace /= eyeSpace.w;

    // Convert to a noramlized ray 
    vec3 ray = eyeSpace.xyz;
    ray = normalize(ray);

    // Adjust the ray by the rotation
    vec4 ray4 = reprojection.rotation * vec4(ray, 1.0);
    ray4 /= ray4.w;
    ray = ray4.xyz;

    // Project back on to the texture plane
    ray *= eyeSpace.z / ray.z;

    // Update the eyespace vector
    eyeSpace.xyz = ray;

    // Reproject back into NDC
    ndcSpace = eyeProjection * eyeSpace;
    
    // Calculate the new UV coordinates
    if (uv.x >= 0.5) {
        uv = toUvFromNdcSpace(ndcSpace);
        uv.x += 1.0;
    } else {
        uv = toUvFromNdcSpace(ndcSpace);
    }
    uv.x /= 2.0;
    
    if (any(greaterThan(uv, uvmax)) || any(lessThan(uv, uvmin))) {
        outFragColor = vec4(0.0, 0.0, 0.0, 1.0);
    } else {
        outFragColor = texture(sampler, uv);
    }
}

